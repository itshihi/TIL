> 디폴트 매개변수
> 다중 정의
> 인라인 함수
> 네임스페이스


### 1. 
#### default 매개변수
- C++에서는 함수 원형에 초깃값을 기술할 수 있다.
- 매개변수의 디폴트 값을 '선언'한 함수는 호출자 코드에서 실인수를 생략한 채 호출할 수 있다.

```cpp
int TestFunc(int = 10);

int TestFunc(int nParam) {
	return nParam;
}
``` 

- 호출자의 코드만 보고 '절대로' 함수의 원형을 확정하면 안된다.
- 디폴트값 기술 법칙
    - 피호출자 함수 매개변수의 디폴트 값은 반드시 오른쪽 매개변수부터 해야한다.
    - 매개변수가 여러 개일 때 왼쪽 첫번째의 디폴트 값을 기술하려면, 나머지 오른쪽의 모든 매개변수의 디폴트 값을 빠짐없이 기술해야한다.
    - 호출자 함수가 피호출자 함수 매개변수의 실인수를 기술하면 이는 왼쪽부터 짝을 맞추어 적용되며, 짝이 맞지 않는 매개변수는 디폴트 값을 기술한다.

- 즉, 디폴트 값은 오른쪽 매개변수부터 채운다.
```cpp
int TestFunc(int nParam1, int nParam2=5);
```


### 2. 함수의 다중 정의
#### 함수의 이름은 그대로 사용하면서 한가지 개념을 여러가지 형태로 구현
- 사용자 코드에 있는 함수 호출의 구체적인 대상이 누구인지 '알아서' 식별하는 것이 중요 -> 모호성 내재

```cpp
반환형식 호출규칙 함수이름(매개변수, 매개변수 ....)
```
- 이 중 다중 정의에 영향을 미치는 것은 매개변수뿐이다.(반환형식은 영향X)

### 3. 인라인 함수

(1) 사용 목적
함수 호출로 인한 오버헤드 극복
- CPU가 다른 레지스터와 함께 실행 중인 현재 명령어 주소를 저장해야 하므로 모든 함수 매개 변수를 생성해야 한다. 
-> 매크로 함수를 통한 성능 향상

#### 매크로 함수란?
- 함수처럼 인자를 설정할 수 있는 매크로 의미
- 매개변수에 자료형을 지정할 수 없음


> 매크로: (반복되는) 여러 개의 명령어를 묶어서 하나의 키 입력 동작으로 만든 것



#### 인라인 함수

> 일반함수를 호출하는 경우, 메모리에 일반 함수의 코드를 저장하고 함수를 호출했을 때 해당 함수의 주소로 점프하여 해당 함수의 코드를 실행하고 다시 원래 자리로 되돌아온다.
> 인라인 함수는 함수 호출 코드에 직접 인라인 함수의 코드가 치환되어 실행되므로 주소 영역 점프가 필요하지 않아 함수의 실행속도가 더 빠르다.

- 매크로의 장점과 함수의 장점을 두루 갖춘 함수
- 본질적으로 함수이므로 매개변수에 형식 지정 가능, 내부적으로는 매크로처럼 함수 호출하지 않음
- 함수 원형 앞에 inline이라는 예약어를 작성하면, 컴파일러에서 함수를 인라인 함수로 처리하여 인-플레이스 확장된다.
- 즉 함수 호출이 함수 자체의 내용 복사본으로 대체되어 함수 오버헤드가 제거된다.

```cpp
// 다음의 경우, min() 함수를 두번 호출하여 함수 호출 오버헤드 패널티를 두 번 발생시킴

int max(int x, int y){
    return x>y ? x:y;
}

int main(){
    cout << max(3,6) << endl;
    cout << max(6,1) << endl;
}
```

```cpp
// 인라인화의 경우 다음과 같이 기계 코드를 생성함 -> 결과적으로 빠르게 실행
inline int max(int x, int y){
    return x>y ? x:y;
}

int main(){
    cout << 3>6 ? 3:6 << endl;
    cout << 6>1 ? 6:1 << endl;
}
```

- 다만 같은 코드가 기계어에 계속 반복되어 나오게 되므로 코드의 길이가 어느정도 수준을 넘어서면 인라인 함수가 되는 것음 바람직하지 않음

- 바람직한 코드의 길이의 경우 컴파일러가 결정함.
- VS에서 [구성 속성]->[C++]->[최적화]



<!-- ### 매크로 함수
- 자료형의 독립성 보장
- 내부에서 자기 자신을 호출할 수 없다.

```cpp
#define (매크로 함수 이름) 
#define ADD(a,b) a+b;
```

### 인라인 함수
- 컴파일 단계에서 처리가 이루어진다.
-  -->


### 4. 네임스페이스
C++ 가 지원하는 각종 요소들(변수, 함수, 클래스 등)을 한 범주로 묶어주기 위한 문법 (== 소속, 구역)

- 네임스페이스 선언할 땐, namespace 예약어를 이용해야한다.
```cpp
namespace 이름{
    //시작

    //끝
}
```
- 네임스페이스가 존재할 경우 식별자 앞에 범위 지정 연산자를 이용해 네임스페이스를 기술할 수 있다.
- 소속을 밝힘으로써 여러 사람이 공동으로 프로그램을 만드는 과정에서는 변수나 함수 이름이 겹치는 일을 피할 수 있다.


> using
> namespace를 일일이 작성하기엔 비효율적이므로 using 예약어를 통해 생략


<br>

#### namespace의 중첩
네임스페이스 안에 여러개의 네임스페이스가 속할 수 있다.

```cpp
namespace TEST{
    int nData = 100;
    namespace DEV{
        int nData = 200;

        namespace WIN{
            int nData = 300;
        }
    }
}


int main(){

    cout << TEST::nDATA << endl; // 100
    cout << TEST::DEV::nDATA << endl; //200
    cout << TEST::DEV::WIN::nDATA << endl; //300
}
```
- 다음과 같이 네임스페이스가 다르며 변수명이 같더라도 괜찮다.
- 이 때 정확한 네임스페이스 명시가 필요하다.

- 함수 이름과 매개변수 등이 같더라도 네임스페이스가 다르면 전혀 다른 개별함수로 다중 정의된다.
-> 이 경우 using 예약어 사용 불가능


### 식별자 검색 순서
식별자가 선언된 위치를 검색하는 순서
> 

#### 전역 함수인 경우
> 1. 현재 블록 범위
> 2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
> 3. 가장 최근에 선언된 전역 변수나 함수
> 4. using 선언된 네임스페이스 혹은 전역 네임스페이스. 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생

>
#### 클래스 메서드인 경우
> 1. 현재 블록 범위
> 2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
> 3. 클래스의 멤버
> 4. 부모 클래스의 멤버
> 5. 가장 최근에 선언된 전역 변수나 함수
> 6. 호출자 코드가 속한 네임스페이스의 상위 네임스페이스
> 7. using 선언된 네임스페이스 혹은 전역 네임스페이스 혹은 전역 네임스페이스. 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생!


#### 가장 최근에 선언된 전역 변수
전역변수는 네임스페이스보다 선언된 위치가 더 중요하다.

```cpp
int nData = 100; // 전역변수 선언
namespace TEST{
    void TestFunc(void){
        cout << "TEST::TestFunc()" << endl;
    }
    int nData = 200;
}

// 100 출력
```

```cpp
namespace TEST{
    void TestFunc(void){
        cout << "TEST::TestFunc()" << endl;
    }
    int nData = 100;
}

// 컴파일 오류 발생
```
#### using 선언과 전역 변수

- using namespace 선언을 통해 매번 식별자 앞에 네임스페이스를 기술하는 번거로움을 피하여 편의성과 생산성을 높일 수 있다. 
- 이름이 같지만 네임스페이스가 다른 변수가 여러개일 경우 모호함으로 오류 발생할 수 있다.

```cpp
using namespace std;

int nData = 100; // 전역변수 선언
namespace TEST{
    int nData = 200;

    void TestFunc(void){
        cout << "TEST::TestFunc()" << endl;
    }
}
// 전역변수인 100 출력
```
```cpp
using namespace std;

int nData = 100; // 전역변수 선언
namespace TEST{
    int nData = 200;

    void TestFunc(void){
        cout << "TEST::TestFunc()" << endl;
    }
}

using namespace TEST;

// error C2872 'nData' : 모호한 기호입니다.

```









